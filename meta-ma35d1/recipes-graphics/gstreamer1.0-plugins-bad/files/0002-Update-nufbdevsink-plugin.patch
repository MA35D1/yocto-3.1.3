From 488b4cd72db2269dc2d6be97e6e3437e319137d2 Mon Sep 17 00:00:00 2001
From: "Y.C. Huang" <ychuang3@nuvoton.com>
Date: Thu, 5 Aug 2021 17:20:58 +0800
Subject: [PATCH 2/2] Update nufbdevsink plugin.

1. Fixed performance issue by make nufbdevsink inherit from videoconvert class.
   The H264 1080P playback frame rate improved from 24 fps to 32 fps.
2. Support image up/down-scaling, render position in frame buffer, and rotation.
3. Support run-time image out control. (work with VC8000 kernel module version >= 0.4.1)
---
 sys/nufbdev/gstnufbdevsink.c | 931 ++++++++++++++++++-----------------
 sys/nufbdev/gstnufbdevsink.h |  79 +--
 2 files changed, 525 insertions(+), 485 deletions(-)

diff --git a/sys/nufbdev/gstnufbdevsink.c b/sys/nufbdev/gstnufbdevsink.c
index 9ae345d..47d1ff9 100644
--- a/sys/nufbdev/gstnufbdevsink.c
+++ b/sys/nufbdev/gstnufbdevsink.c
@@ -1,5 +1,8 @@
-/* GStreamer nufbdev plugin
- * Copyright (C) 2007 Sean D'Epagnier <sean@depagnier.com>
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ * This file:
+ * Copyright (C) 2003 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ * Copyright (C) 2010 David Schleef <ds@schleef.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -17,13 +20,22 @@
  * Boston, MA 02110-1301, USA.
  */
 
-/* currently the driver does not switch modes, instead uses current mode.
-   the video is centered and cropped if needed to fit onscreen.
-   Whatever bitdepth is set is used, and tested to work for 16, 24, 32 bits
-*/
+/**
+ * SECTION:element-nufbdevsink
+ * @title: nufbdevsink
+ *
+ * Convert video frames between a great variety of video formats.
+ *
+ * ## Example launch line
+ * |[
+ * gst-launch-1.0 -v gst-launch-1.0 filesrc location=./example.264 ! decodebin ! nufbdevsink
+ * ]|
+ *  This will directly output the VC8000 H264 + PP result image to frame buffer device.
+ *
+ */
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+#  include "config.h"
 #endif
 
 #include <stdio.h>
@@ -49,560 +61,585 @@
 
 #include <linux/videodev2.h>
 
-#define ENABLE_LOCAL_DEBUG
+#include <gst/video/video.h>
+#include <gst/video/gstvideometa.h>
+#include <gst/video/gstvideopool.h>
 
-#ifdef ENABLE_LOCAL_DEBUG
-#define debug_msg     printf
-#else
-#define debug_msg(...)
-#endif
+#include <string.h>
+
+GST_DEBUG_CATEGORY (nufbdevsink_debug);
+#define GST_CAT_DEFAULT nufbdevsink_debug
+GST_DEBUG_CATEGORY_STATIC (CAT_PERFORMANCE);
+
+GType gst_nufbdevsink_get_type (void);
+
+static GQuark _colorspace_quark;
+
+#define gst_nufbdevsink_parent_class parent_class
+G_DEFINE_TYPE (GstVideoConvert, gst_nufbdevsink, GST_TYPE_VIDEO_FILTER);
+
+#define DEFAULT_PROP_DITHER      GST_VIDEO_DITHER_BAYER
+#define DEFAULT_PROP_DITHER_QUANTIZATION 1
+#define DEFAULT_PROP_CHROMA_RESAMPLER	GST_VIDEO_RESAMPLER_METHOD_LINEAR
+#define DEFAULT_PROP_ALPHA_MODE GST_VIDEO_ALPHA_MODE_COPY
+#define DEFAULT_PROP_ALPHA_VALUE 1.0
+#define DEFAULT_PROP_CHROMA_MODE GST_VIDEO_CHROMA_MODE_FULL
+#define DEFAULT_PROP_MATRIX_MODE GST_VIDEO_MATRIX_MODE_FULL
+#define DEFAULT_PROP_GAMMA_MODE GST_VIDEO_GAMMA_MODE_NONE
+#define DEFAULT_PROP_PRIMARIES_MODE GST_VIDEO_PRIMARIES_MODE_NONE
+#define DEFAULT_PROP_N_THREADS 1
+#define DEFAULT_PROP_X_POS 0
+#define DEFAULT_PROP_Y_POS 0
+#define DEFAULT_PROP_WIDTH 1024
+#define DEFAULT_PROP_HEIGHT 600
+#define DEFAULT_PROP_ROTATE 0
 
 enum
 {
-  ARG_0,
-  ARG_DEVICE
+  PROP_0,
+  PROP_DITHER,
+  PROP_DITHER_QUANTIZATION,
+  PROP_CHROMA_RESAMPLER,
+  PROP_ALPHA_MODE,
+  PROP_ALPHA_VALUE,
+  PROP_CHROMA_MODE,
+  PROP_MATRIX_MODE,
+  PROP_GAMMA_MODE,
+  PROP_PRIMARIES_MODE,
+  PROP_N_THREADS,
+  PROP_X_POS,
+  PROP_Y_POS,
+  PROP_WIDTH,
+  PROP_HEIGHT,
+  PROP_ROTATE
 };
 
+#define CSP_VIDEO_CAPS GST_VIDEO_CAPS_MAKE (GST_VIDEO_FORMATS_ALL) ";" \
+    GST_VIDEO_CAPS_MAKE_WITH_FEATURES ("ANY", GST_VIDEO_FORMATS_ALL)
 
-typedef struct _GstCapsArrayElement
-{
-  GstStructure *structure;
-  GstCapsFeatures *features;
-} GstCapsArrayElement;
-
-typedef struct _GstCapsImpl
-{
-  GstCaps caps;
-
-  GArray *array;
-} GstCapsImpl;
-
-#define GST_CAPS_ARRAY(c) (((GstCapsImpl *)(c))->array)
-
-#define GST_CAPS_LEN(c)   (GST_CAPS_ARRAY(c)->len)
-
-
-
-
-#if 0
-static void gst_nufbdevsink_get_times (GstBaseSink * basesink,
-    GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
-#endif
-
-
-
-static GstFlowReturn gst_nufbdevsink_show_frame (GstVideoSink * videosink,
-    GstBuffer * buff);
-
-static gboolean gst_nufbdevsink_start (GstBaseSink * bsink);
-static gboolean gst_nufbdevsink_stop (GstBaseSink * bsink);
+static GstStaticPadTemplate gst_video_convert_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (CSP_VIDEO_CAPS)
+    );
 
-static GstCaps *gst_nufbdevsink_getcaps (GstBaseSink * bsink, GstCaps * filter);
-static gboolean gst_nufbdevsink_setcaps (GstBaseSink * bsink, GstCaps * caps);
+static GstStaticPadTemplate gst_nufbdevsink_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (CSP_VIDEO_CAPS)
+    );
 
-static void gst_nufbdevsink_finalize (GObject * object);
 static void gst_nufbdevsink_set_property (GObject * object,
-    guint prop_id, const GValue * value, GParamSpec * pspec);
+    guint property_id, const GValue * value, GParamSpec * pspec);
 static void gst_nufbdevsink_get_property (GObject * object,
-    guint prop_id, GValue * value, GParamSpec * pspec);
-static GstStateChangeReturn gst_nufbdevsink_change_state (GstElement * element,
-    GstStateChange transition);
+    guint property_id, GValue * value, GParamSpec * pspec);
 
-#define VIDEO_CAPS "{ I420, NV12, RGB, BGR, BGRx, xBGR, RGB, RGBx, ARGB, RGB16 }"
+static gboolean gst_nufbdevsink_set_info (GstVideoFilter * filter,
+    GstCaps * incaps, GstVideoInfo * in_info, GstCaps * outcaps,
+    GstVideoInfo * out_info);
+static GstFlowReturn gst_nufbdevsink_transform_frame (GstVideoFilter * filter,
+    GstVideoFrame * in_frame, GstVideoFrame * out_frame);
 
-static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (VIDEO_CAPS))
-    );
+/* copies the given caps */
+static GstCaps *
+gst_nufbdevsink_caps_remove_format_info (GstCaps * caps)
+{
+  GstStructure *st;
+  GstCapsFeatures *f;
+  gint i, n;
+  GstCaps *res;
 
-#define parent_class gst_nufbdevsink_parent_class
-G_DEFINE_TYPE (GstNUFBDEVSink, gst_nufbdevsink, GST_TYPE_VIDEO_SINK);
+  res = gst_caps_new_empty ();
 
-static void
-gst_nufbdevsink_init (GstNUFBDEVSink * nufbdevsink)
-{
-  struct vc8k_pp_params  *pp;
-  char  dev_name[32];
-  int   i;
+  n = gst_caps_get_size (caps);
+  for (i = 0; i < n; i++) {
+    st = gst_caps_get_structure (caps, i);
+    f = gst_caps_get_features (caps, i);
 
-  debug_msg("%s\n", __func__);
+    /* If this is already expressed by the existing caps
+     * skip this structure */
+    if (i > 0 && gst_caps_is_subset_structure_full (res, st, f))
+      continue;
 
-  if (!nufbdevsink->device) {
-    nufbdevsink->device = g_strdup ("/dev/fb0");
-  }
-  nufbdevsink->fd = open (nufbdevsink->device, O_RDWR);
+    st = gst_structure_copy (st);
+    /* Only remove format info for the cases when we can actually convert */
+    if (!gst_caps_features_is_any (f)
+        && gst_caps_features_is_equal (f,
+            GST_CAPS_FEATURES_MEMORY_SYSTEM_MEMORY))
+      gst_structure_remove_fields (st, "format", "colorimetry", "chroma-site",
+          NULL);
 
-  if (nufbdevsink->fd == -1)
-    return;
+    gst_caps_append_structure_full (res, st, gst_caps_features_copy (f));
+  }
 
-  /* get the fixed screen info */
-  if (ioctl (nufbdevsink->fd, FBIOGET_FSCREENINFO, &nufbdevsink->fixinfo))
-    goto err_out;
+  return res;
+}
 
-  /* get the variable screen info */
-  if (ioctl (nufbdevsink->fd, FBIOGET_VSCREENINFO, &nufbdevsink->varinfo))
-    goto err_out;
+/* The caps can be transformed into any other caps with format info removed.
+ * However, we should prefer passthrough, so if passthrough is possible,
+ * put it first in the list. */
+static GstCaps *
+gst_nufbdevsink_transform_caps (GstBaseTransform * btrans,
+    GstPadDirection direction, GstCaps * caps, GstCaps * filter)
+{
+  GstCaps *tmp, *tmp2;
+  GstCaps *result;
+  GstCaps *ret;
+  GstStructure *structure;
+  GstVideoInfo info;
+  GstCapsFeatures *features;
+  gint i, n;
 
-  /* map the framebuffer */
-  nufbdevsink->framebuffer = mmap (0, nufbdevsink->fixinfo.smem_len,
-      PROT_WRITE, MAP_SHARED, nufbdevsink->fd, 0);
-  if (nufbdevsink->framebuffer == MAP_FAILED)
-    goto err_out;
-    
-  nufbdevsink->format = GST_VIDEO_FORMAT_ARGB;   /* hard fix to ARGB */
+  GST_DEBUG_OBJECT (btrans,
+      "Transforming caps %" GST_PTR_FORMAT " in direction %s", caps,
+      (direction == GST_PAD_SINK) ? "sink" : "src");
 
-  ioctl(nufbdevsink->fd, FBIOPAN_DISPLAY, &nufbdevsink->varinfo);
+  ret = gst_caps_new_empty ();
+  n = gst_caps_get_size (caps);
+  for (i = 0; i < n; i++) {
+    structure = gst_caps_get_structure (caps, i);
+    features = gst_caps_get_features (caps, i);
 
-  /*-----------------------------------------------*/
-  /*  VC8000 PP control                            */
-  /*-----------------------------------------------*/
-  pp = &nufbdevsink->pp;
-  pp->enable_pp = 1;
-  pp->frame_buf_w = nufbdevsink->varinfo.xres;
-  pp->frame_buf_h = nufbdevsink->varinfo.yres;
-  pp->img_out_x = 0;
-  pp->img_out_y = 0;
-  pp->img_out_w = nufbdevsink->varinfo.xres;
-  pp->img_out_h = nufbdevsink->varinfo.yres;
-  pp->rotation = PP_ROTATION_NONE;
-  
-  if (nufbdevsink->format == GST_VIDEO_FORMAT_ARGB)
-    pp->img_out_fmt = V4L2_PIX_FMT_ARGB32;
-  else if (nufbdevsink->format == GST_VIDEO_FORMAT_RGB16)
-    pp->img_out_fmt = V4L2_PIX_FMT_RGB565;
-  else
-    pp->img_out_fmt = V4L2_PIX_FMT_NV12;
-  
-  for (i = 0; i < 10; i++) {
-    sprintf(dev_name, "/dev/video%d", i);
-    nufbdevsink->fd_vc8k = open(dev_name, O_RDWR);
-    if (nufbdevsink->fd_vc8k == -1)
-      continue;
-    
-    if (ioctl(nufbdevsink->fd_vc8k, VC8KIOC_PP_SET_CONFIG, nufbdevsink->pp) != 0) {
-      debug_msg("VC8KIOC_PP_SET_CONFIG failed (%s)", strerror(errno));
+    /* If this is already expressed by the existing caps
+     * skip this structure */
+    if (i > 0 && gst_caps_is_subset_structure_full (ret, structure, features))
       continue;
-    }
-    else
-      break;
-  }
-  if (i < 10) {
-    debug_msg("VC8000 %s opened.\n", dev_name);
-    return;
-  }
 
-err_out:
-  close (nufbdevsink->fd);
-  nufbdevsink->fd = -1;
-  debug_msg("gst_nufbdevsink_init failed!\n");
-}
+    /* make copy */
+    structure = gst_structure_copy (structure);
 
-#if 0
-static void
-gst_nufbdevsink_get_times (GstBaseSink * basesink, GstBuffer * buffer,
-    GstClockTime * start, GstClockTime * end)
-{
-  GstNUFBDEVSink *nufbdevsink;
-
-  nufbdevsink = GST_NUFBDEVSINK (basesink);
-
-  if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer)) {
-    *start = GST_BUFFER_TIMESTAMP (buffer);
-    if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
-      *end = *start + GST_BUFFER_DURATION (buffer);
-    } else {
-      if (nufbdevsink->fps_n > 0) {
-        *end = *start +
-            gst_util_uint64_scale_int (GST_SECOND, nufbdevsink->fps_d,
-            nufbdevsink->fps_n);
+    /* If the features are non-sysmem we can only do passthrough */
+    if (!gst_caps_features_is_any (features)
+        && gst_caps_features_is_equal (features,
+            GST_CAPS_FEATURES_MEMORY_SYSTEM_MEMORY)) {
+      gst_structure_set (structure, "width", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+          "height", GST_TYPE_INT_RANGE, 1, G_MAXINT, NULL);
+
+      /* if pixel aspect ratio, make a range of it */
+      if (gst_structure_has_field (structure, "pixel-aspect-ratio")) {
+        gst_structure_set (structure, "pixel-aspect-ratio",
+            GST_TYPE_FRACTION_RANGE, 1, G_MAXINT, G_MAXINT, 1, NULL);
       }
     }
+    gst_caps_append_structure_full (ret, structure,
+        gst_caps_features_copy (features));
   }
-}
-#endif
 
-static GstCaps *
-gst_nufbdevsink_getcaps (GstBaseSink * bsink, GstCaps * filter)
-{
-  GstNUFBDEVSink *nufbdevsink;
-  //GstVideoFormat format;
-  GstCaps *caps;
-  //uint32_t rmask;
-  //uint32_t gmask;
-  //uint32_t bmask;
-  //uint32_t tmask;
-  //int endianness, depth, bpp;
+#if 1
+  if (filter) {
+    GstCaps *intersection;
 
-  nufbdevsink = GST_NUFBDEVSINK (bsink);
+    intersection =
+        gst_caps_intersect_full (filter, ret, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (ret);
+    ret = intersection;
+  }
 
-  caps = gst_static_pad_template_get_caps (&sink_template);
+  return ret;
+#else
+  /* Get all possible caps that we can transform to */
+  tmp = gst_nufbdevsink_caps_remove_format_info (caps);
 
-#if 0
-  /* FIXME: locking */
-  if (!nufbdevsink->framebuffer)
-    goto done;
-
-  bpp = nufbdevsink->varinfo.bits_per_pixel;
-
-  rmask = ((1 << nufbdevsink->varinfo.red.length) - 1)
-      << nufbdevsink->varinfo.red.offset;
-  gmask = ((1 << nufbdevsink->varinfo.green.length) - 1)
-      << nufbdevsink->varinfo.green.offset;
-  bmask = ((1 << nufbdevsink->varinfo.blue.length) - 1)
-      << nufbdevsink->varinfo.blue.offset;
-  tmask = ((1 << nufbdevsink->varinfo.transp.length) - 1)
-      << nufbdevsink->varinfo.transp.offset;
-
-  depth = nufbdevsink->varinfo.red.length + nufbdevsink->varinfo.green.length
-      + nufbdevsink->varinfo.blue.length;
-
-  switch (nufbdevsink->varinfo.bits_per_pixel) {
-    case 32:
-      /* swap endianness of masks */
-      rmask = GUINT32_SWAP_LE_BE (rmask);
-      gmask = GUINT32_SWAP_LE_BE (gmask);
-      bmask = GUINT32_SWAP_LE_BE (bmask);
-      tmask = GUINT32_SWAP_LE_BE (tmask);
-      depth += nufbdevsink->varinfo.transp.length;
-      endianness = G_BIG_ENDIAN;
-      break;
-    case 24:{
-      /* swap red and blue masks */
-      tmask = rmask;
-      rmask = bmask;
-      bmask = tmask;
-      tmask = 0;
-      endianness = G_BIG_ENDIAN;
-      break;
-    }
-    case 15:
-    case 16:
-      tmask = 0;
-      endianness = G_LITTLE_ENDIAN;
-      break;
-    default:
-      goto unsupported_bpp;
+  if (filter) {
+    tmp2 = gst_caps_intersect_full (filter, tmp, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (tmp);
+    tmp = tmp2;
   }
 
-  format = gst_video_format_from_masks (depth, bpp, endianness, rmask, gmask,
-      bmask, tmask);
-
-  debug_msg("%s, %d, format = %s\n", __func__, __LINE__, gst_video_format_to_string(format));
+  result = tmp;
 
-  if (format == GST_VIDEO_FORMAT_UNKNOWN)
-    goto unknown_format;
+  GST_DEBUG_OBJECT (btrans, "transformed %" GST_PTR_FORMAT " into %"
+      GST_PTR_FORMAT, caps, result);
 
-  caps = gst_caps_make_writable (caps);
-  gst_caps_set_simple (caps, "format", G_TYPE_STRING,
-      gst_video_format_to_string (format), NULL);
-#else
-  caps = gst_caps_make_writable (caps);
-#endif
+  return result;
+#endif  
+}
 
-  debug_msg("%s, nufbdevsink caps [%s]\n", __func__, gst_caps_to_string(caps));
 
-done:
+static gboolean
+gst_nufbdevsink_set_info (GstVideoFilter * filter,
+    GstCaps * incaps, GstVideoInfo * in_info, GstCaps * outcaps,
+    GstVideoInfo * out_info)
+{
+  GstVideoConvert *space;
 
-  if (filter != NULL) {
-    GstCaps *icaps;
+  space = GST_VIDEO_CONVERT_CAST (filter);
 
-    // debug_msg("%s %d, filter [%s], len = %d\n", __func__, __LINE__, gst_caps_to_string(filter), GST_CAPS_LEN(filter));
-    // icaps = gst_caps_intersect (caps, filter);
-    icaps = gst_caps_copy(filter);
-    
-    gst_caps_unref (caps);
-    caps = icaps;
+  if (space->convert) {
+    gst_video_converter_free (space->convert);
+    space->convert = NULL;
   }
 
-  if (caps)
-        debug_msg("%s, return caps name: %s\n", __func__, gst_caps_to_string(caps));
-  else
-        debug_msg("%s, return caps is NULL!!\n", __func__);
+#if 0
+  space->convert = gst_video_converter_new (in_info, out_info,
+      gst_structure_new ("GstVideoConvertConfig",
+          GST_VIDEO_CONVERTER_OPT_DITHER_METHOD, GST_TYPE_VIDEO_DITHER_METHOD,
+          space->dither,
+          GST_VIDEO_CONVERTER_OPT_DITHER_QUANTIZATION, G_TYPE_UINT,
+          space->dither_quantization,
+          GST_VIDEO_CONVERTER_OPT_CHROMA_RESAMPLER_METHOD,
+          GST_TYPE_VIDEO_RESAMPLER_METHOD, space->chroma_resampler,
+          GST_VIDEO_CONVERTER_OPT_ALPHA_MODE,
+          GST_TYPE_VIDEO_ALPHA_MODE, space->alpha_mode,
+          GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE,
+          G_TYPE_DOUBLE, space->alpha_value,
+          GST_VIDEO_CONVERTER_OPT_CHROMA_MODE,
+          GST_TYPE_VIDEO_CHROMA_MODE, space->chroma_mode,
+          GST_VIDEO_CONVERTER_OPT_MATRIX_MODE,
+          GST_TYPE_VIDEO_MATRIX_MODE, space->matrix_mode,
+          GST_VIDEO_CONVERTER_OPT_GAMMA_MODE,
+          GST_TYPE_VIDEO_GAMMA_MODE, space->gamma_mode,
+          GST_VIDEO_CONVERTER_OPT_PRIMARIES_MODE,
+          GST_TYPE_VIDEO_PRIMARIES_MODE, space->primaries_mode,
+          GST_VIDEO_CONVERTER_OPT_THREADS, G_TYPE_UINT,
+          space->n_threads, NULL));
+  if (space->convert == NULL)
+    goto no_convert;
+
+  GST_DEBUG ("reconfigured %d %d", GST_VIDEO_INFO_FORMAT (in_info),
+      GST_VIDEO_INFO_FORMAT (out_info));
+#endif
 
-  return caps;
+  return TRUE;
 
-#if 0
-/* ERRORS */
-unsupported_bpp:
+  /* ERRORS */
+format_mismatch:
   {
-    GST_WARNING_OBJECT (bsink, "unsupported bit depth: %d", bpp);
-    return NULL;
+    GST_ERROR_OBJECT (space, "input and output formats do not match");
+    return FALSE;
   }
-unknown_format:
+no_convert:
   {
-    GST_WARNING_OBJECT (bsink, "could not map nufbdev format to GstVideoFormat: "
-        "depth=%u, bpp=%u, endianness=%u, rmask=0x%08x, gmask=0x%08x, "
-        "bmask=0x%08x, tmask=0x%08x", depth, bpp, endianness, rmask, gmask,
-        bmask, tmask);
-    return NULL;
+    GST_ERROR_OBJECT (space, "could not create converter");
+    return FALSE;
   }
-#endif  
 }
 
-static gboolean
-gst_nufbdevsink_setcaps (GstBaseSink * bsink, GstCaps * vscapslist)
+static void
+gst_nufbdevsink_finalize (GObject * obj)
 {
-#if 0	
-  GstNUFBDEVSink *nufbdevsink;
-  GstStructure *structure;
-  const GValue *fps;
-
-  nufbdevsink = GST_NUFBDEVSINK (bsink);
-
-  structure = gst_caps_get_structure (vscapslist, 0);
-
-  fps = gst_structure_get_value (structure, "framerate");
-  nufbdevsink->fps_n = gst_value_get_fraction_numerator (fps);
-  nufbdevsink->fps_d = gst_value_get_fraction_denominator (fps);
-
-  gst_structure_get_int (structure, "width", &nufbdevsink->width);
-  gst_structure_get_int (structure, "height", &nufbdevsink->height);
+  GstVideoConvert *space = GST_VIDEO_CONVERT (obj);
 
-  /* calculate centering and scanlengths for the video */
-  nufbdevsink->bytespp =
-      nufbdevsink->fixinfo.line_length / nufbdevsink->varinfo.xres_virtual;
+  if (space->framebuffer != NULL)
+    munmap (space->framebuffer, space->fixinfo.smem_len);
+  close (space->fd);
+  close(space->fd_vc8k);
 
-  nufbdevsink->cx = ((int) nufbdevsink->varinfo.xres - nufbdevsink->width) / 2;
-  if (nufbdevsink->cx < 0)
-    nufbdevsink->cx = 0;
-
-  nufbdevsink->cy = ((int) nufbdevsink->varinfo.yres - nufbdevsink->height) / 2;
-  if (nufbdevsink->cy < 0)
-    nufbdevsink->cy = 0;
-
-  nufbdevsink->linelen = nufbdevsink->width * nufbdevsink->bytespp;
-  if (nufbdevsink->linelen > nufbdevsink->fixinfo.line_length)
-    nufbdevsink->linelen = nufbdevsink->fixinfo.line_length;
+  if (space->convert) {
+    gst_video_converter_free (space->convert);
+  }
 
-  nufbdevsink->lines = nufbdevsink->height;
-  if (nufbdevsink->lines > nufbdevsink->varinfo.yres)
-    nufbdevsink->lines = nufbdevsink->varinfo.yres;
-#endif
-  return TRUE;
+  G_OBJECT_CLASS (parent_class)->finalize (obj);
 }
 
-
-static GstFlowReturn
-gst_nufbdevsink_show_frame (GstVideoSink * videosink, GstBuffer * buf)
+static void
+gst_nufbdevsink_class_init (GstVideoConvertClass * klass)
 {
-#if 0
-  GstNUFBDEVSink *nufbdevsink;
-  GstMapInfo map;
-  int i;
-
-
-  nufbdevsink = GST_NUFBDEVSINK (videosink);
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstBaseTransformClass *gstbasetransform_class =
+      (GstBaseTransformClass *) klass;
+  GstVideoFilterClass *gstvideofilter_class = (GstVideoFilterClass *) klass;
 
-  /* optimization could remove this memcpy by allocating the buffer
-     in framebuffer memory, but would only work when xres matches
-     the video width */
-  if (!gst_buffer_map (buf, &map, GST_MAP_READ))
-    return GST_FLOW_ERROR;
-
-  for (i = 0; i < nufbdevsink->lines; i++) {
-    memcpy (nufbdevsink->framebuffer
-        + (i + nufbdevsink->cy) * nufbdevsink->fixinfo.line_length
-        + nufbdevsink->cx * nufbdevsink->bytespp,
-        map.data + i * nufbdevsink->width * nufbdevsink->bytespp,
-        nufbdevsink->linelen);
-  }
+  gobject_class->set_property = gst_nufbdevsink_set_property;
+  gobject_class->get_property = gst_nufbdevsink_get_property;
+  gobject_class->finalize = gst_nufbdevsink_finalize;
 
-  gst_buffer_unmap (buf, &map);
-#endif
-  return GST_FLOW_OK;
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_video_convert_src_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_nufbdevsink_sink_template);
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "MA35D1 VC8000 fb render", "Filter/Converter/Video",
+      "Render MA35D1 VC8000 output image to frame buffer",
+      "Nuvoton");
+
+  gstbasetransform_class->transform_caps =
+      GST_DEBUG_FUNCPTR (gst_nufbdevsink_transform_caps);
+//  gstbasetransform_class->fixate_caps =
+//      GST_DEBUG_FUNCPTR (gst_video_convert_fixate_caps);
+//  gstbasetransform_class->filter_meta =
+//      GST_DEBUG_FUNCPTR (gst_video_convert_filter_meta);
+//  gstbasetransform_class->transform_meta =
+//      GST_DEBUG_FUNCPTR (gst_video_convert_transform_meta);
+
+  gstbasetransform_class->passthrough_on_same_caps = FALSE;
+
+  gstvideofilter_class->set_info =
+      GST_DEBUG_FUNCPTR (gst_nufbdevsink_set_info);
+  gstvideofilter_class->transform_frame =
+      GST_DEBUG_FUNCPTR (gst_nufbdevsink_transform_frame);
+
+  g_object_class_install_property (gobject_class, PROP_N_THREADS,
+      g_param_spec_uint ("n-threads", "Threads",
+          "Maximum number of threads to use", 0, G_MAXUINT,
+          DEFAULT_PROP_N_THREADS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_X_POS,
+      g_param_spec_int ("x-pos", "X-Pos",
+          "X coordinate of frame buffer to render the output image", 0, 1920,
+          DEFAULT_PROP_X_POS,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_CONTROLLABLE));
+  g_object_class_install_property (gobject_class, PROP_Y_POS,
+      g_param_spec_int ("y-pos", "Y-Pos",
+          "Y coordinate of frame buffer to render the output image", 0, 1080,
+          DEFAULT_PROP_Y_POS, 
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_CONTROLLABLE));
+  g_object_class_install_property (gobject_class, PROP_WIDTH,
+      g_param_spec_int ("width", "Width",
+          "Width of the VC8000 output image", 0, 1920,
+          DEFAULT_PROP_WIDTH, 
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_CONTROLLABLE));
+  g_object_class_install_property (gobject_class, PROP_HEIGHT,
+      g_param_spec_int ("height", "Height",
+          "Height of the VC8000 output image", 0, 1088,
+          DEFAULT_PROP_HEIGHT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_CONTROLLABLE));
+  g_object_class_install_property (gobject_class, PROP_ROTATE,
+      g_param_spec_int ("rotate", "Rotate",
+          "Rotation of the VC8000 output image", 0, 3,
+          DEFAULT_PROP_ROTATE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_CONTROLLABLE));
 }
 
-static gboolean
-gst_nufbdevsink_start (GstBaseSink * bsink)
+static void
+gst_nufbdevsink_init (GstVideoConvert * space)
 {
-#if 0
-  GstNUFBDEVSink *nufbdevsink;
   struct vc8k_pp_params  *pp;
   char  dev_name[32];
   int   i;
 
-  nufbdevsink = GST_NUFBDEVSINK (bsink);
-
-  debug_msg("%s\n", __func__);
-  if (!nufbdevsink->device) {
-    nufbdevsink->device = g_strdup ("/dev/fb0");
+  printf("gst_nufbdevsink_init %s %s\n", __DATE__, __TIME__);
+  space->dither = DEFAULT_PROP_DITHER;
+  space->dither_quantization = DEFAULT_PROP_DITHER_QUANTIZATION;
+  space->chroma_resampler = DEFAULT_PROP_CHROMA_RESAMPLER;
+  space->alpha_mode = DEFAULT_PROP_ALPHA_MODE;
+  space->alpha_value = DEFAULT_PROP_ALPHA_VALUE;
+  space->chroma_mode = DEFAULT_PROP_CHROMA_MODE;
+  space->matrix_mode = DEFAULT_PROP_MATRIX_MODE;
+  space->gamma_mode = DEFAULT_PROP_GAMMA_MODE;
+  space->primaries_mode = DEFAULT_PROP_PRIMARIES_MODE;
+  space->n_threads = DEFAULT_PROP_N_THREADS;
+
+  if (!space->device) {
+    space->device = g_strdup ("/dev/fb0");
   }
+  space->fd = open (space->device, O_RDWR);
 
-  nufbdevsink->fd = open (nufbdevsink->device, O_RDWR);
-
-  if (nufbdevsink->fd == -1)
-    return FALSE;
+  if (space->fd == -1)
+    return;
 
   /* get the fixed screen info */
-  if (ioctl (nufbdevsink->fd, FBIOGET_FSCREENINFO, &nufbdevsink->fixinfo))
-    return FALSE;
+  if (ioctl (space->fd, FBIOGET_FSCREENINFO, &space->fixinfo)) {
+    close(space->fd);
+    return;
+  }
 
   /* get the variable screen info */
-  if (ioctl (nufbdevsink->fd, FBIOGET_VSCREENINFO, &nufbdevsink->varinfo))
-    return FALSE;
-    
-  nufbdevsink->format = GST_VIDEO_FORMAT_ARGB;   /* hard fix to ARGB */
-
-  /* map the framebuffer */
-  nufbdevsink->framebuffer = mmap (0, nufbdevsink->fixinfo.smem_len,
-      PROT_WRITE, MAP_SHARED, nufbdevsink->fd, 0);
-  if (nufbdevsink->framebuffer == MAP_FAILED)
-    return FALSE;
-#endif
-
-  return TRUE;
-}
-
-static gboolean
-gst_nufbdevsink_stop (GstBaseSink * bsink)
-{
-#if 0
-  GstNUFBDEVSink *nufbdevsink;
+  if (ioctl (space->fd, FBIOGET_VSCREENINFO, &space->varinfo)) {
+    close(space->fd);
+    return;
+  }
 
-  nufbdevsink = GST_NUFBDEVSINK (bsink);
+  space->format = GST_VIDEO_FORMAT_ARGB;   /* hard fix to ARGB */
 
-  if (munmap (nufbdevsink->framebuffer, nufbdevsink->fixinfo.smem_len))
-    return FALSE;
+  /* map the framebuffer */
+  space->framebuffer = mmap (0, space->fixinfo.smem_len,
+      PROT_WRITE, MAP_SHARED, space->fd, 0);
+  if (space->framebuffer == MAP_FAILED)
+    space->framebuffer = NULL;
 
-  if (close (nufbdevsink->fd))
-    return FALSE;
+  ioctl(space->fd, FBIOPAN_DISPLAY, &space->varinfo);
 
-  nufbdevsink->pp.enable_pp = 0;
-  ioctl(nufbdevsink->fd_vc8k, VC8KIOC_PP_SET_CONFIG, nufbdevsink->pp);
-  close(nufbdevsink->fd_vc8k);
-#endif
-
-  return TRUE;
-}
+  /*-----------------------------------------------*/
+  /*  VC8000 PP control                            */
+  /*-----------------------------------------------*/
+  pp = &space->pp;
+  pp->enable_pp = 1;
+  pp->frame_buf_w = space->varinfo.xres;
+  pp->frame_buf_h = space->varinfo.yres;
+  pp->img_out_x = 0;
+  pp->img_out_y = 0;
+  pp->img_out_w = space->varinfo.xres;
+  pp->img_out_h = space->varinfo.yres;
+  pp->rotation = PP_ROTATION_NONE;
 
-static void
-gst_nufbdevsink_set_property (GObject * object, guint prop_id,
-    const GValue * value, GParamSpec * pspec)
-{
-  GstNUFBDEVSink *nufbdevsink;
+  if (space->format == GST_VIDEO_FORMAT_ARGB)
+    pp->img_out_fmt = V4L2_PIX_FMT_ARGB32;
+  else if (space->format == GST_VIDEO_FORMAT_RGB16)
+    pp->img_out_fmt = V4L2_PIX_FMT_RGB565;
+  else
+    pp->img_out_fmt = V4L2_PIX_FMT_NV12;
 
-  nufbdevsink = GST_NUFBDEVSINK (object);
+  for (i = 0; i < 10; i++) {
+    sprintf(dev_name, "/dev/video%d", i);
+    space->fd_vc8k = open(dev_name, O_RDWR);
+    if (space->fd_vc8k == -1)
+      continue;
 
-  switch (prop_id) {
-    case ARG_DEVICE:{
-      g_free (nufbdevsink->device);
-      nufbdevsink->device = g_value_dup_string (value);
-      break;
+    if (ioctl(space->fd_vc8k, VC8KIOC_PP_SET_CONFIG, space->pp) != 0) {
+      printf("VC8KIOC_PP_SET_CONFIG failed (%s)", strerror(errno));
+      continue;
     }
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    else
       break;
   }
+  if (i < 10) {
+    printf("VC8000 %s opened.\n", dev_name);
+    return;
+  }
+  printf("gst_nufbdevsink_init done\n");
 }
 
-
-static void
-gst_nufbdevsink_get_property (GObject * object, guint prop_id, GValue * value,
-    GParamSpec * pspec)
+void
+gst_nufbdevsink_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
 {
-  GstNUFBDEVSink *nufbdevsink;
+  GstVideoConvert *csp;
+  struct vc8k_pp_params  *pp;
 
-  nufbdevsink = GST_NUFBDEVSINK (object);
+  csp = GST_VIDEO_CONVERT (object);
+  pp = &csp->pp;
 
-  switch (prop_id) {
-    case ARG_DEVICE:{
-      g_value_set_string (value, nufbdevsink->device);
+  switch (property_id) {
+    case PROP_DITHER:
+      csp->dither = g_value_get_enum (value);
+      break;
+    case PROP_CHROMA_RESAMPLER:
+      csp->chroma_resampler = g_value_get_enum (value);
+      break;
+    case PROP_ALPHA_MODE:
+      csp->alpha_mode = g_value_get_enum (value);
+      break;
+    case PROP_ALPHA_VALUE:
+      csp->alpha_value = g_value_get_double (value);
+      break;
+    case PROP_CHROMA_MODE:
+      csp->chroma_mode = g_value_get_enum (value);
+      break;
+    case PROP_MATRIX_MODE:
+      csp->matrix_mode = g_value_get_enum (value);
+      break;
+    case PROP_GAMMA_MODE:
+      csp->gamma_mode = g_value_get_enum (value);
+      break;
+    case PROP_PRIMARIES_MODE:
+      csp->primaries_mode = g_value_get_enum (value);
+      break;
+    case PROP_DITHER_QUANTIZATION:
+      csp->dither_quantization = g_value_get_uint (value);
+      break;
+    case PROP_N_THREADS:
+      csp->n_threads = g_value_get_uint (value);
+      break;
+    case PROP_X_POS:
+      //printf("%s x-pos = %d\n", __func__, g_value_get_int (value));
+      pp->img_out_x = g_value_get_int (value);
+      break;
+    case PROP_Y_POS:
+      //printf("%s y-pos = %d\n", __func__, g_value_get_int (value));
+      pp->img_out_y = g_value_get_int (value);
+      break;
+    case PROP_WIDTH:
+      //printf("%s width = %d\n", __func__, g_value_get_int (value));
+      pp->img_out_w = g_value_get_int (value);
+      break;
+    case PROP_HEIGHT:
+      //printf("%s height = %d\n", __func__, g_value_get_int (value));
+      pp->img_out_h = g_value_get_int (value);
+      break;
+    case PROP_ROTATE:
+      //printf("%s rotate = %d\n", __func__, g_value_get_int (value));
+      pp->rotation = g_value_get_int (value);
       break;
-    }
     default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
   }
+  ioctl(csp->fd_vc8k, VC8KIOC_PP_SET_CONFIG, csp->pp);
 }
 
-static GstStateChangeReturn
-gst_nufbdevsink_change_state (GstElement * element, GstStateChange transition)
+void
+gst_nufbdevsink_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
 {
-  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstVideoConvert *csp;
 
-  g_return_val_if_fail (GST_IS_NUFBDEVSINK (element), GST_STATE_CHANGE_FAILURE);
+  csp = GST_VIDEO_CONVERT (object);
 
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-
-  switch (transition) {
+  switch (property_id) {
+    case PROP_DITHER:
+      g_value_set_enum (value, csp->dither);
+      break;
+    case PROP_CHROMA_RESAMPLER:
+      g_value_set_enum (value, csp->chroma_resampler);
+      break;
+    case PROP_ALPHA_MODE:
+      g_value_set_enum (value, csp->alpha_mode);
+      break;
+    case PROP_ALPHA_VALUE:
+      g_value_set_double (value, csp->alpha_value);
+      break;
+    case PROP_CHROMA_MODE:
+      g_value_set_enum (value, csp->chroma_mode);
+      break;
+    case PROP_MATRIX_MODE:
+      g_value_set_enum (value, csp->matrix_mode);
+      break;
+    case PROP_GAMMA_MODE:
+      g_value_set_enum (value, csp->gamma_mode);
+      break;
+    case PROP_PRIMARIES_MODE:
+      g_value_set_enum (value, csp->primaries_mode);
+      break;
+    case PROP_DITHER_QUANTIZATION:
+      g_value_set_uint (value, csp->dither_quantization);
+      break;
+    case PROP_N_THREADS:
+      g_value_set_uint (value, csp->n_threads);
+      break;
     default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
   }
-  return ret;
 }
 
-static gboolean
-plugin_init (GstPlugin * plugin)
-{
-  if (!gst_element_register (plugin, "nufbdevsink", GST_RANK_NONE,
-          GST_TYPE_NUFBDEVSINK))
-    return FALSE;
-
-  return TRUE;
-}
-
-static void
-gst_nufbdevsink_class_init (GstNUFBDEVSinkClass * klass)
+static GstFlowReturn
+gst_nufbdevsink_transform_frame (GstVideoFilter * filter,
+    GstVideoFrame * in_frame, GstVideoFrame * out_frame)
 {
-  GObjectClass *gobject_class;
-  GstElementClass *gstelement_class;
-  GstBaseSinkClass *basesink_class;
-  GstVideoSinkClass *videosink_class;
+  GstVideoConvert *space;
 
-  gobject_class = (GObjectClass *) klass;
-  gstelement_class = (GstElementClass *) klass;
-  basesink_class = (GstBaseSinkClass *) klass;
-  videosink_class = (GstVideoSinkClass *) klass;
+  space = GST_VIDEO_CONVERT_CAST (filter);
 
-  gobject_class->set_property = gst_nufbdevsink_set_property;
-  gobject_class->get_property = gst_nufbdevsink_get_property;
-  gobject_class->finalize = gst_nufbdevsink_finalize;
-
-  gstelement_class->change_state =
-      GST_DEBUG_FUNCPTR (gst_nufbdevsink_change_state);
-
-  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_DEVICE,
-      g_param_spec_string ("device", "device",
-          "The framebuffer device eg: /dev/fb0", NULL, G_PARAM_READWRITE));
-
-  basesink_class->set_caps = GST_DEBUG_FUNCPTR (gst_nufbdevsink_setcaps);
-  basesink_class->get_caps = GST_DEBUG_FUNCPTR (gst_nufbdevsink_getcaps);
-#if 0
-  basesink_class->get_times = GST_DEBUG_FUNCPTR (gst_nufbdevsink_get_times);
-#endif
-  basesink_class->start = GST_DEBUG_FUNCPTR (gst_nufbdevsink_start);
-  basesink_class->stop = GST_DEBUG_FUNCPTR (gst_nufbdevsink_stop);
+  GST_CAT_DEBUG_OBJECT (CAT_PERFORMANCE, filter,
+      "doing colorspace conversion from %s -> to %s",
+      GST_VIDEO_INFO_NAME (&filter->in_info),
+      GST_VIDEO_INFO_NAME (&filter->out_info));
 
-  videosink_class->show_frame = GST_DEBUG_FUNCPTR (gst_nufbdevsink_show_frame);
+//  gst_video_converter_frame (space->convert, in_frame, out_frame);
 
-  gst_element_class_set_static_metadata (gstelement_class, "nufbdev video sink",
-      "Sink/Video", "Linux framebuffer videosink",
-      "Sean D'Epagnier <sean@depagnier.com>");
-
-  gst_element_class_add_static_pad_template (gstelement_class, &sink_template);
+  return GST_FLOW_OK;
 }
 
-static void
-gst_nufbdevsink_finalize (GObject * object)
+static gboolean
+plugin_init (GstPlugin * plugin)
 {
-  GstNUFBDEVSink *nufbdevsink = GST_NUFBDEVSINK (object);
+  GST_DEBUG_CATEGORY_INIT (nufbdevsink_debug, "nufbdevsink", 0,
+      "Colorspace Converter");
 
-#if 1
-  munmap (nufbdevsink->framebuffer, nufbdevsink->fixinfo.smem_len);
-  close (nufbdevsink->fd);
-  nufbdevsink->pp.enable_pp = 0;
-  ioctl(nufbdevsink->fd_vc8k, VC8KIOC_PP_SET_CONFIG, nufbdevsink->pp);
-  close(nufbdevsink->fd_vc8k);
-#endif
+  GST_DEBUG_CATEGORY_GET (CAT_PERFORMANCE, "GST_PERFORMANCE");
 
-  g_free (nufbdevsink->device);
+  _colorspace_quark = g_quark_from_static_string ("colorspace");
 
-  G_OBJECT_CLASS (parent_class)->finalize (object);
+  return gst_element_register (plugin, "nufbdevsink",
+      GST_RANK_NONE, GST_TYPE_VIDEO_CONVERT);
 }
 
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
-    nufbdevsink,
-    "Linux framebuffer video sink",
-    plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
+    nufbdevsink, "MA35D1 VC8000 PP", plugin_init, VERSION, GST_LICENSE,
+    GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/sys/nufbdev/gstnufbdevsink.h b/sys/nufbdev/gstnufbdevsink.h
index 3c487d2..3f03c38 100644
--- a/sys/nufbdev/gstnufbdevsink.h
+++ b/sys/nufbdev/gstnufbdevsink.h
@@ -1,5 +1,7 @@
 /* GStreamer
- * Copyright (C) 2007 Sean D'Epagnier sean@depagnier.com
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ * This file:
+ * Copyright (C) 2003 Ronald Bultje <rbultje@ronald.bitfreak.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -17,13 +19,13 @@
  * Boston, MA 02110-1301, USA.
  */
 
-
-#ifndef __GST_NUFBDEVSINK_H__
-#define __GST_NUFBDEVSINK_H__
+#ifndef __GST_VIDEOCONVERT_H__
+#define __GST_VIDEOCONVERT_H__
 
 #include <gst/gst.h>
-#include <gst/video/gstvideosink.h>
 #include <gst/video/video.h>
+#include <gst/video/gstvideofilter.h>
+#include <gst/video/gstvideosink.h>
 
 #include <linux/fb.h>
 
@@ -54,53 +56,54 @@ struct vc8k_pp_params {
 #define PP_ROTATION_VER_FLIP                            4U
 #define PP_ROTATION_180                                 5U
 
-
 G_BEGIN_DECLS
 
-#define GST_TYPE_NUFBDEVSINK \
-  (gst_nufbdevsink_get_type())
-#define GST_NUFBDEVSINK(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_NUFBDEVSINK,GstNUFBDEVSink))
-#define GST_NUFBDEVSINK_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_NUFBDEVSINK,GstNUFBDEVSinkClass))
-#define GST_IS_NUFBDEVSINK(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NUFBDEVSINK))
-#define GST_IS_NUFBDEVSINK_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NUFBDEVSINK))
+#define GST_TYPE_VIDEO_CONVERT	          (gst_nufbdevsink_get_type())
+#define GST_VIDEO_CONVERT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_CONVERT,GstVideoConvert))
+#define GST_VIDEO_CONVERT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_CONVERT,GstVideoConvertClass))
+#define GST_IS_VIDEO_CONVERT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_CONVERT))
+#define GST_IS_VIDEO_CONVERT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_CONVERT))
+#define GST_VIDEO_CONVERT_CAST(obj)       ((GstVideoConvert *)(obj))
 
-typedef struct _GstNUFBDEVSink GstNUFBDEVSink;
-typedef struct _GstNUFBDEVSinkClass GstNUFBDEVSinkClass;
+typedef struct _GstVideoConvert GstVideoConvert;
+typedef struct _GstVideoConvertClass GstVideoConvertClass;
 
-struct _GstNUFBDEVSink {
-  GstVideoSink videosink;
+/**
+ * GstVideoConvert:
+ *
+ * Opaque object data structure.
+ */
+struct _GstVideoConvert {
+  GstVideoFilter element;
+
+  GstVideoConverter *convert;
+  GstVideoDitherMethod dither;
+  guint dither_quantization;
+  GstVideoResamplerMethod chroma_resampler;
+  GstVideoAlphaMode alpha_mode;
+  GstVideoChromaMode chroma_mode;
+  GstVideoMatrixMode matrix_mode;
+  GstVideoGammaMode gamma_mode;
+  GstVideoPrimariesMode primaries_mode;
+  gdouble alpha_value;
+  gint n_threads;
 
   /*< private >*/
+  GstVideoFormat  format;
   struct fb_fix_screeninfo fixinfo;
   struct fb_var_screeninfo varinfo;
-
-  int fd;
+  char  *device;
   unsigned char *framebuffer;
-
-  char *device;
-
-  GstVideoFormat  format;
-  int width, height;
-  int cx, cy, linelen, lines, bytespp;
-
-  int fps_n, fps_d;
-  
+  int   fd;
   int   fd_vc8k;
   struct vc8k_pp_params  pp;
 };
 
-struct _GstNUFBDEVSinkClass {
-  GstVideoSinkClass videosink_class;
-
+struct _GstVideoConvertClass
+{
+  GstVideoFilterClass parent_class;
 };
 
-GType gst_nufbdevsink_get_type(void);
-
 G_END_DECLS
 
-
-#endif /* __GST_NUFBDEVSINK_H__ */
+#endif /* __GST_VIDEOCONVERT_H__ */
-- 
2.17.1

